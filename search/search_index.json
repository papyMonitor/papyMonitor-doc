{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to papyMonitor papyMonitor (called after host ) is a multiplatform (Windows, Linux, Mac) tool to interact with any embedded system (called after target ). It can receive/edit/monitor/simulate data and send commands to the target via the serial port. Arduino (all flavors supported), PIC, AVR, ARM, RPI, a computer or whatever equiped with a serial port is supported. The tool provides a multifunction plotter, a 3D view to simulate the target attached mechanical systems and a way to load/save variables tagged as parameters. The GUI and the behavior are fully customizable with one User Configuration File (called after UCF ) based on Lua scripting language. It is fast, real time (the embedded system is the master) and proudly made with Godot Engine. How it works? The user write the UCF that describe the application behavior (what to do with the variables, editing, displaying, ploting, linking with a move on a 3D shape,...). On the target side, a provided small C library (CPP for Arduino) gives the necessary functions for the communication as well as a structure to store the variables (and callbacks if any) to be reported/modified. The protocol used over the serial port is choosen as plain ASCII text. Each line is terminated with a '\\n' . It is very simple, the variables are sent one at a time from the target to host at a regular interval, this interval is choosen by the target. Depending on the variable type, a line has at max 13 chars included the '\\n' . This protocol was sucessfully tested at 10000 samples/per second at 2MBaud on a Cortex-M4. The code on Godot Engine takes the received lines asynchronously, at its frame rate, and process them. Documentation The User Configuration File (UCF) describes the format and the structure of the UCF Installation and usage provide informations for installing and using the tool on platforms papyMonitor GUI describes the application The Arduino target files describes the Arduino library and how to use it The generic C target files describes the general C library and how to use it The GUI application explains how to use the GUI application Discussions Feel free to post comments on Discussions page","title":"Welcome to papyMonitor"},{"location":"#welcome-to-papymonitor","text":"papyMonitor (called after host ) is a multiplatform (Windows, Linux, Mac) tool to interact with any embedded system (called after target ). It can receive/edit/monitor/simulate data and send commands to the target via the serial port. Arduino (all flavors supported), PIC, AVR, ARM, RPI, a computer or whatever equiped with a serial port is supported. The tool provides a multifunction plotter, a 3D view to simulate the target attached mechanical systems and a way to load/save variables tagged as parameters. The GUI and the behavior are fully customizable with one User Configuration File (called after UCF ) based on Lua scripting language. It is fast, real time (the embedded system is the master) and proudly made with Godot Engine.","title":"Welcome to papyMonitor"},{"location":"#how-it-works","text":"The user write the UCF that describe the application behavior (what to do with the variables, editing, displaying, ploting, linking with a move on a 3D shape,...). On the target side, a provided small C library (CPP for Arduino) gives the necessary functions for the communication as well as a structure to store the variables (and callbacks if any) to be reported/modified. The protocol used over the serial port is choosen as plain ASCII text. Each line is terminated with a '\\n' . It is very simple, the variables are sent one at a time from the target to host at a regular interval, this interval is choosen by the target. Depending on the variable type, a line has at max 13 chars included the '\\n' . This protocol was sucessfully tested at 10000 samples/per second at 2MBaud on a Cortex-M4. The code on Godot Engine takes the received lines asynchronously, at its frame rate, and process them.","title":"How it works?"},{"location":"#documentation","text":"The User Configuration File (UCF) describes the format and the structure of the UCF Installation and usage provide informations for installing and using the tool on platforms papyMonitor GUI describes the application The Arduino target files describes the Arduino library and how to use it The generic C target files describes the general C library and how to use it The GUI application explains how to use the GUI application","title":"Documentation"},{"location":"#discussions","text":"Feel free to post comments on Discussions page","title":"Discussions"},{"location":"configLuafile/","text":"The User Configuration File (UCF) UCF is in fact a Lua file. It is for sure not necessary to know the Lua language to create or manipulate the file, but respecting the Lua syntax is mandatory. Also, it is a good idea to have an editor with Lua syntax coloration, it helps to see any mistake, especially a missing bracket. There are three main objects in the file: 1) The Default object: cfg:Default({ --parameters }) This object appears only once at the beginning of the file. Inside are the parameters for the communication and the gui layouting. 2) The Variable object: cfg:Variable({ --parameters }) This object is used for representing one variable -or several variables in an array- that is reported by the target. The file can have many objects of this kind. 3) The Solid object: cfg:Solid({ --parameters }) This object is used for representing a 3D shape in the 3D view. The file can have many objects of this kind. Syntax Each of the three objects has this special syntax: cfg:XXX({ --parameters }) Don't worry about this, that means only that Lua calls the embedded function XXX with parameters given between { } (a table in Lua). All the parameters follow the simple syntax: Key = Value, (may have spaces around the = ) (notice the comma at the end of the line, this one is optional if the parameter is the last one) Depending of the Key, the Value can be a string, a boolean ( true or false ), a Lua function (see further), a Lua table (again something surrounded by { } ) or a simple numerical value. The file can have comments, all characters following -- are ignored. The Default object This object is described here after with all its possible Keys, explanations are inside: cfg:Default({ ---------------------- -- Mandatory fields -- ---------------------- Baudrate = 460800, -- Must match the baudrate used by the target -- Commands from monitor to target; SetValue = '#', -- Don't modify this ReportValueOn = '?', -- Don't modify this ReportValueOff = '!', -- Don't modify this -- Messages from target to monitor IReportValue = ':', -- Don't modify this IReportTextConsole = '>', -- Don't modify this --Every sampleTimeHW a variable is sent SampleTimeHW= 0.001, -- Must match the one of the target for correct -- timing display --- GUI LAYOUTING -- This Key is responsible for the variables displaying. The -- variables are referenced by their indexes (integer value). A tab -- (example Tab0) has a name and may contains several columns. -- The columns are all in the Columns Key. GroupTabs= { -- There are two groups of tabs {-- group0 NoExpandX=true, -- Means strech horizontally the group to -- its elements, optional, default=false Tabs = { -- There are two tabs in the group { -- Tab0 TabName=\"Example 0\", Columns= { -- There are two columns in the tab { 0, 9, }, -- This column has two rows { 10, }, -- This column has one row } }, { -- Tab1 TabName=\"Example 1\", Columns= { { 20, 29, }, { 30, }, } }, }, {-- group1 --NoExpandX=true, Tabs = { -- There is one tab in the group { -- Tab0 TabName=\"Example 2\", Columns= { -- There is one column in the tab { 100 }, } }, } }, ---------------------- -- Optional fields -- ---------------------- -- Indianess of the target, usually little -- Other value: 'big' Endian = 'little', -- default = 'little' -- If 3D view requested, set this to true Vue3D = true, -- default = false -- If plot view requested, set to true Plot = true, -- default = false }) The Variable object At first, an example with the mandatory fields is presented here after: --------------- cfg:Variable({ Name=\"My byte\", -- Name that appears in front of the variable Type=\"B\", -- Variable type, here a byte Index=0, -- Variable index in the target structure variables -- Use also this index in the GroupTabs LAYOUT -- for displaying }) On the GUI, it's rendered like this: The variable type can be one of the following (excerpt of monitoring.h): typedef enum { eComDataType_Float = 'f', // 8 chars eComDataType_U32 = 'W', // 8 chars eComDataType_I32 = 'w', // 8 chars eComDataType_U16 = 'I', // 4 chars eComDataType_I16 = 'i', // 4 chars eComDataType_U8 = 'B', // 2 chars eComDataType_I8 = 'b', // 2 chars } eDataType_t; With a special Key in the object, one can embed 8 bool type in the byte type. Another case with all the Key recognized: --------------- cfg:Variable({ Name=\"My unsigned 16\", Type=\"I\", Index=0, --- Optional Keys -- The variable belong to the parameter group \"Base parameters\" Parameter=\"Base parameters\", -- if Parameter Key ommited, variable -- has no parameter group -- HideData=false, -- if set to true, the variable isn't displayed, -- this is mainly used with the \"Button\" WidgetType -- (default = false) Scroll=false, -- used mainly if the variable is an array, put a -- vertical scrolbar on the widget (default=false) WidgetType=\"SliderH\", -- can be \"Normal\" (default), \"SliderH\", -- \"SliderV\" and \"Button\" SliderMin = 0, -- mandatory only if WidgetType=\"SliderH\" or -- \"SliderV\": Minimum value of the slider SliderMax = 1000, -- mandatory only if WidgetType=\"SliderH\" or -- \"SliderV\": Maximum value of the slider Data = { -- we will see this Key after -- parameters }, }) The Data Key permits on a one hand to adjust the value parameter and on the other hand to define an array of values: --------------- cfg:Variable({ Name=\"My float\", Type=\"f\", Index=0, --- Optional Keys Data = { { -- all is optional BoolsOnU8=false,-- use only with \"B\" type (default=false) Value= 0.0, -- a default value, if Key ommited Value = 0 CanEdit=true, -- permit to the user to edit the value and -- send it to the target when he press enter -- (default=false) CanPlot=true, -- when true, add this variable to the plot list -- of the plotter Precision=5, -- for \"f\" type variable, the number of decimal -- digits to display (default = 3) SingleText = \"\",-- in case of array of values, the text to -- display in front of each variable -- (default = \"\") }, }, }) Then for example if one wants to report a float variable with editing and plotting capability and with a display precision of 1, the Variable object is like this: --------------- cfg:Variable({ Name=\"My float\", Type=\"f\", Index=10, --- Optional Keys Data = { { CanEdit=true, CanPlot=true, Precision=1 }, -- Data0, index 10 }, }) It is possible to display several consecutive indexes in an array: --------------- cfg:Variable({ Name=\"Arm 0 values\", Type=\"f\", Index=20, -- In a array, this index is the base index Data= { { SingleText = \"PID P value\" }, -- Data0, index 20 { SingleText = \"PID I value\" }, -- Data1, index 21 { SingleText = \"PID D value\" }, { SingleText = \"FeedF value\" }, { SingleText = \"Set value\", CanEdit=true }, { SingleText = \"PID Control\" }, { SingleText = \"Simul square\", CanEdit=true }, { SingleText = \"Simul sq velo\", CanEdit=true }, { SingleText = \"System filter\", CanEdit=true }, -- Data8, index 28 } }) On the GUI, it's rendered like this: It's possible to display/edit bool values, for this the type must be \"B\" and the Key BoolsOnU8 must be set to true : --------------- cfg:Variable({ Name=\"Simulation\", Type=\"B\", Index=115, Data= { { -- Data0 BoolsOnU8=true, -- when set, tell to display the byte -- as 8 booleans (default=false) --- Optional Key BitsTexts = { \"simulSquareCH0\", \"simulSquareCH1\", \"simulSquareCH2\", \"simulSquareCH3\", \"simulSquareCH4\", \"Not used\", \"Not used\", \"Not used\" }, --- Optional Key CanBitsEdits = { true,true,true,true, true,false,false,false }, } } }) On the GUI, it's rendered like this, notice the smalls buttons s (set) and c (clear) to set/clear the bit. The Solid object The example below shows a Solid object, it is used to render any 3D shape in the 3D view The simplest Solid definition: --------------- cfg:Solid({ -- Mandatory fields Parent=\"Root\", -- see after Name=\"Sol\", -- The name of the Solid Body=\"Cube\", -- Shape rendered, can be \"Cube\", \"Sphere\" -- and \"Cylinder\" A solid definition with all the Key accepted: --------------- cfg:Solid({ -- Mandatory fields Parent=\"Root\", -- The string value \"Root\" is reserved to the system -- It tells that this Solid is connected to the 3D -- scene origin. Name=\"Sol\", -- The name of the Solid Body=\"Cube\", -- Shape rendered, can be \"Cube\", \"Sphere\" -- and \"Cylinder\" -- Optional fields StartPosition={ 0, 0.5, -0.2 }, -- Offset position in the scene {x,y,z} -- default: {0,0,0} StartRotation={ 0, 90, 0 }, -- Offset rotation in the scene {x,y,z} -- default: {0,0,0} CubeSize = { 5, 0.1, 10 }, -- Cube dimension if Body=\"Cube\" -- default: {1,1,1} CylinderTopRadius= 1, -- Cylinder dimension if Body=\"Cylinder\" -- default: {1,1,1} CylinderBottomRadius= 1, -- Cylinder dimension if Body=\"Cylinder\" -- default: {1,1,1} CylinderHeight= 1, -- Cylinder dimension if Body=\"Cylinder\" -- default: {1,1,1} SphereRadius= 1, -- Sphere dimension if Body=\"Sphere\" -- default: {1,1,1} SphereHeight= 1, -- Sphere dimension if Body=\"Sphere\" -- default: {1,1,1} MoveRotationSmooth=true, -- Enable smooth rotation, default=false MovePositionSmooth=true, -- Enable smooth translation, default=false Color={ 0.4, 0.3, 0.2 }, -- Color of the shape {red, green, blue} -- values are from 0.0 to 1.0 -- default = {1,1,1} Formula = -- If omitted, no Formula, if present must respect -- this syntax. self is an object given by the system -- for the user to manipulate variables function(self) -- end, -- don't forget the comma if there is another key after Formula }) A solid definition with a Formula key: cfg:Solid({ -- Mandatory fields Parent=\"Sol\", -- Notice that this solid is referenced to \"Sol\" Solid -- defined before. Then its position and rotation is -- referenced to the \"Sol\" origin Name=\"Bras0\", Body=\"Cube\", -- Optional fields StartPosition={ 0, 0.5, -0.2 }, StartRotation={ 0, 45, 0 }, Color={ 0.4, 0.3, 0.3 }, MoveRotationSmooth=true, Formula = function(self) self.R.y = 90 - self:GetVariable(9) -- Here the Solid rotation around the y axis is related -- with the variable value of index 9 end, }) Objects availables for the key Formula System variables P : current positions of the solid, accessed with self.P.x , self.P.y and self.P.z R : current rotations of the solid, accessed with self.R.x , self.R.y and self.R.z System functions GetVariable(index) : access the variable value of index index GetVariable(index, bitindex) : access the variable value of index index and return the nth bitindex bit value as a number ( 0 or 1 ) Lua functions All Lua functions are available","title":"The User Configuration File (UCF)"},{"location":"configLuafile/#the-user-configuration-file-ucf","text":"UCF is in fact a Lua file. It is for sure not necessary to know the Lua language to create or manipulate the file, but respecting the Lua syntax is mandatory. Also, it is a good idea to have an editor with Lua syntax coloration, it helps to see any mistake, especially a missing bracket. There are three main objects in the file: 1) The Default object: cfg:Default({ --parameters }) This object appears only once at the beginning of the file. Inside are the parameters for the communication and the gui layouting. 2) The Variable object: cfg:Variable({ --parameters }) This object is used for representing one variable -or several variables in an array- that is reported by the target. The file can have many objects of this kind. 3) The Solid object: cfg:Solid({ --parameters }) This object is used for representing a 3D shape in the 3D view. The file can have many objects of this kind.","title":"The User Configuration File (UCF)"},{"location":"configLuafile/#syntax","text":"Each of the three objects has this special syntax: cfg:XXX({ --parameters }) Don't worry about this, that means only that Lua calls the embedded function XXX with parameters given between { } (a table in Lua). All the parameters follow the simple syntax: Key = Value, (may have spaces around the = ) (notice the comma at the end of the line, this one is optional if the parameter is the last one) Depending of the Key, the Value can be a string, a boolean ( true or false ), a Lua function (see further), a Lua table (again something surrounded by { } ) or a simple numerical value. The file can have comments, all characters following -- are ignored.","title":"Syntax"},{"location":"configLuafile/#the-default-object","text":"This object is described here after with all its possible Keys, explanations are inside: cfg:Default({ ---------------------- -- Mandatory fields -- ---------------------- Baudrate = 460800, -- Must match the baudrate used by the target -- Commands from monitor to target; SetValue = '#', -- Don't modify this ReportValueOn = '?', -- Don't modify this ReportValueOff = '!', -- Don't modify this -- Messages from target to monitor IReportValue = ':', -- Don't modify this IReportTextConsole = '>', -- Don't modify this --Every sampleTimeHW a variable is sent SampleTimeHW= 0.001, -- Must match the one of the target for correct -- timing display --- GUI LAYOUTING -- This Key is responsible for the variables displaying. The -- variables are referenced by their indexes (integer value). A tab -- (example Tab0) has a name and may contains several columns. -- The columns are all in the Columns Key. GroupTabs= { -- There are two groups of tabs {-- group0 NoExpandX=true, -- Means strech horizontally the group to -- its elements, optional, default=false Tabs = { -- There are two tabs in the group { -- Tab0 TabName=\"Example 0\", Columns= { -- There are two columns in the tab { 0, 9, }, -- This column has two rows { 10, }, -- This column has one row } }, { -- Tab1 TabName=\"Example 1\", Columns= { { 20, 29, }, { 30, }, } }, }, {-- group1 --NoExpandX=true, Tabs = { -- There is one tab in the group { -- Tab0 TabName=\"Example 2\", Columns= { -- There is one column in the tab { 100 }, } }, } }, ---------------------- -- Optional fields -- ---------------------- -- Indianess of the target, usually little -- Other value: 'big' Endian = 'little', -- default = 'little' -- If 3D view requested, set this to true Vue3D = true, -- default = false -- If plot view requested, set to true Plot = true, -- default = false })","title":"The Default object"},{"location":"configLuafile/#the-variable-object","text":"At first, an example with the mandatory fields is presented here after: --------------- cfg:Variable({ Name=\"My byte\", -- Name that appears in front of the variable Type=\"B\", -- Variable type, here a byte Index=0, -- Variable index in the target structure variables -- Use also this index in the GroupTabs LAYOUT -- for displaying }) On the GUI, it's rendered like this: The variable type can be one of the following (excerpt of monitoring.h): typedef enum { eComDataType_Float = 'f', // 8 chars eComDataType_U32 = 'W', // 8 chars eComDataType_I32 = 'w', // 8 chars eComDataType_U16 = 'I', // 4 chars eComDataType_I16 = 'i', // 4 chars eComDataType_U8 = 'B', // 2 chars eComDataType_I8 = 'b', // 2 chars } eDataType_t; With a special Key in the object, one can embed 8 bool type in the byte type. Another case with all the Key recognized: --------------- cfg:Variable({ Name=\"My unsigned 16\", Type=\"I\", Index=0, --- Optional Keys -- The variable belong to the parameter group \"Base parameters\" Parameter=\"Base parameters\", -- if Parameter Key ommited, variable -- has no parameter group -- HideData=false, -- if set to true, the variable isn't displayed, -- this is mainly used with the \"Button\" WidgetType -- (default = false) Scroll=false, -- used mainly if the variable is an array, put a -- vertical scrolbar on the widget (default=false) WidgetType=\"SliderH\", -- can be \"Normal\" (default), \"SliderH\", -- \"SliderV\" and \"Button\" SliderMin = 0, -- mandatory only if WidgetType=\"SliderH\" or -- \"SliderV\": Minimum value of the slider SliderMax = 1000, -- mandatory only if WidgetType=\"SliderH\" or -- \"SliderV\": Maximum value of the slider Data = { -- we will see this Key after -- parameters }, }) The Data Key permits on a one hand to adjust the value parameter and on the other hand to define an array of values: --------------- cfg:Variable({ Name=\"My float\", Type=\"f\", Index=0, --- Optional Keys Data = { { -- all is optional BoolsOnU8=false,-- use only with \"B\" type (default=false) Value= 0.0, -- a default value, if Key ommited Value = 0 CanEdit=true, -- permit to the user to edit the value and -- send it to the target when he press enter -- (default=false) CanPlot=true, -- when true, add this variable to the plot list -- of the plotter Precision=5, -- for \"f\" type variable, the number of decimal -- digits to display (default = 3) SingleText = \"\",-- in case of array of values, the text to -- display in front of each variable -- (default = \"\") }, }, }) Then for example if one wants to report a float variable with editing and plotting capability and with a display precision of 1, the Variable object is like this: --------------- cfg:Variable({ Name=\"My float\", Type=\"f\", Index=10, --- Optional Keys Data = { { CanEdit=true, CanPlot=true, Precision=1 }, -- Data0, index 10 }, }) It is possible to display several consecutive indexes in an array: --------------- cfg:Variable({ Name=\"Arm 0 values\", Type=\"f\", Index=20, -- In a array, this index is the base index Data= { { SingleText = \"PID P value\" }, -- Data0, index 20 { SingleText = \"PID I value\" }, -- Data1, index 21 { SingleText = \"PID D value\" }, { SingleText = \"FeedF value\" }, { SingleText = \"Set value\", CanEdit=true }, { SingleText = \"PID Control\" }, { SingleText = \"Simul square\", CanEdit=true }, { SingleText = \"Simul sq velo\", CanEdit=true }, { SingleText = \"System filter\", CanEdit=true }, -- Data8, index 28 } }) On the GUI, it's rendered like this: It's possible to display/edit bool values, for this the type must be \"B\" and the Key BoolsOnU8 must be set to true : --------------- cfg:Variable({ Name=\"Simulation\", Type=\"B\", Index=115, Data= { { -- Data0 BoolsOnU8=true, -- when set, tell to display the byte -- as 8 booleans (default=false) --- Optional Key BitsTexts = { \"simulSquareCH0\", \"simulSquareCH1\", \"simulSquareCH2\", \"simulSquareCH3\", \"simulSquareCH4\", \"Not used\", \"Not used\", \"Not used\" }, --- Optional Key CanBitsEdits = { true,true,true,true, true,false,false,false }, } } }) On the GUI, it's rendered like this, notice the smalls buttons s (set) and c (clear) to set/clear the bit.","title":"The Variable object"},{"location":"configLuafile/#the-solid-object","text":"The example below shows a Solid object, it is used to render any 3D shape in the 3D view The simplest Solid definition: --------------- cfg:Solid({ -- Mandatory fields Parent=\"Root\", -- see after Name=\"Sol\", -- The name of the Solid Body=\"Cube\", -- Shape rendered, can be \"Cube\", \"Sphere\" -- and \"Cylinder\" A solid definition with all the Key accepted: --------------- cfg:Solid({ -- Mandatory fields Parent=\"Root\", -- The string value \"Root\" is reserved to the system -- It tells that this Solid is connected to the 3D -- scene origin. Name=\"Sol\", -- The name of the Solid Body=\"Cube\", -- Shape rendered, can be \"Cube\", \"Sphere\" -- and \"Cylinder\" -- Optional fields StartPosition={ 0, 0.5, -0.2 }, -- Offset position in the scene {x,y,z} -- default: {0,0,0} StartRotation={ 0, 90, 0 }, -- Offset rotation in the scene {x,y,z} -- default: {0,0,0} CubeSize = { 5, 0.1, 10 }, -- Cube dimension if Body=\"Cube\" -- default: {1,1,1} CylinderTopRadius= 1, -- Cylinder dimension if Body=\"Cylinder\" -- default: {1,1,1} CylinderBottomRadius= 1, -- Cylinder dimension if Body=\"Cylinder\" -- default: {1,1,1} CylinderHeight= 1, -- Cylinder dimension if Body=\"Cylinder\" -- default: {1,1,1} SphereRadius= 1, -- Sphere dimension if Body=\"Sphere\" -- default: {1,1,1} SphereHeight= 1, -- Sphere dimension if Body=\"Sphere\" -- default: {1,1,1} MoveRotationSmooth=true, -- Enable smooth rotation, default=false MovePositionSmooth=true, -- Enable smooth translation, default=false Color={ 0.4, 0.3, 0.2 }, -- Color of the shape {red, green, blue} -- values are from 0.0 to 1.0 -- default = {1,1,1} Formula = -- If omitted, no Formula, if present must respect -- this syntax. self is an object given by the system -- for the user to manipulate variables function(self) -- end, -- don't forget the comma if there is another key after Formula }) A solid definition with a Formula key: cfg:Solid({ -- Mandatory fields Parent=\"Sol\", -- Notice that this solid is referenced to \"Sol\" Solid -- defined before. Then its position and rotation is -- referenced to the \"Sol\" origin Name=\"Bras0\", Body=\"Cube\", -- Optional fields StartPosition={ 0, 0.5, -0.2 }, StartRotation={ 0, 45, 0 }, Color={ 0.4, 0.3, 0.3 }, MoveRotationSmooth=true, Formula = function(self) self.R.y = 90 - self:GetVariable(9) -- Here the Solid rotation around the y axis is related -- with the variable value of index 9 end, })","title":"The Solid object"},{"location":"configLuafile/#objects-availables-for-the-key-formula","text":"","title":"Objects availables for the key Formula"},{"location":"configLuafile/#system-variables","text":"P : current positions of the solid, accessed with self.P.x , self.P.y and self.P.z R : current rotations of the solid, accessed with self.R.x , self.R.y and self.R.z","title":"System variables"},{"location":"configLuafile/#system-functions","text":"GetVariable(index) : access the variable value of index index GetVariable(index, bitindex) : access the variable value of index index and return the nth bitindex bit value as a number ( 0 or 1 )","title":"System functions"},{"location":"configLuafile/#lua-functions","text":"All Lua functions are available","title":"Lua functions"},{"location":"installation/","text":"Installation and usage To install the application, go to Releases and select/download the file that suits your platform. Save the zipped file in a folder of your choice. The executable on Windows is papyMonitor.x86_64.exe , on Linux is papyMonitor.x86_64 and on MAC is TBD (we don't know) Target Arduino The papyMonitor folder of papyMonitor-arduino repository is a library that you must put on your sketchbook location. To see where your sketchbook location is, open the Arduino IDE then select Files->Preferences: A popup windows will show the \"Settings\" tab, the location is under the \"Sketchbook location\". Open this location on your disk and you'll find a folder \"libraries\". Copy the folder \"papyMonitor\" inside the folder \"libraries\". That's it! Usage/Documentation For each sketch you make (.ino file) you must write a matching .lua file for the papyMonitor application to understand what is coming from the serial port. See the The Arduino target files documentation and see the examples in the folder examples of the papyMonitor-arduino repository. Target other (Generic C target files) Simply copy the two files ( monitoring.h and monitoring.c ) of the papyMonitor-microcontroller-generic repository to your project folder and reference them for compilation. Usage/Documentation For each firmware you make, you must write a matching .lua file for the papyMonitor application to understand what is coming from the serial port. See the The generic C target files documentation and see the examples in the folder examples of papyMonitor-microcontroller-generic repository.","title":"Installation and usage"},{"location":"installation/#installation-and-usage","text":"To install the application, go to Releases and select/download the file that suits your platform. Save the zipped file in a folder of your choice. The executable on Windows is papyMonitor.x86_64.exe , on Linux is papyMonitor.x86_64 and on MAC is TBD (we don't know)","title":"Installation and usage"},{"location":"installation/#target-arduino","text":"The papyMonitor folder of papyMonitor-arduino repository is a library that you must put on your sketchbook location. To see where your sketchbook location is, open the Arduino IDE then select Files->Preferences: A popup windows will show the \"Settings\" tab, the location is under the \"Sketchbook location\". Open this location on your disk and you'll find a folder \"libraries\". Copy the folder \"papyMonitor\" inside the folder \"libraries\". That's it!","title":"Target Arduino"},{"location":"installation/#usagedocumentation","text":"For each sketch you make (.ino file) you must write a matching .lua file for the papyMonitor application to understand what is coming from the serial port. See the The Arduino target files documentation and see the examples in the folder examples of the papyMonitor-arduino repository.","title":"Usage/Documentation"},{"location":"installation/#target-other-generic-c-target-files","text":"Simply copy the two files ( monitoring.h and monitoring.c ) of the papyMonitor-microcontroller-generic repository to your project folder and reference them for compilation.","title":"Target other (Generic C target files)"},{"location":"installation/#usagedocumentation_1","text":"For each firmware you make, you must write a matching .lua file for the papyMonitor application to understand what is coming from the serial port. See the The generic C target files documentation and see the examples in the folder examples of papyMonitor-microcontroller-generic repository.","title":"Usage/Documentation"},{"location":"targetfilesArduinoCPP/","text":"The Arduino target files The papyMonitor folder of papyMonitor-arduino repository contains two files to include on your project, see installation instruction. How it works Each sketch must have some mandatory lines, here after is the minimal sketch to use together with the library // Mandatory include #include \"papyMonitor.hpp\" // Some variables to monitor // ... // ... // ... // The structure where you put your variables // to monitor. The library uses this sVariables_t variables[] = { // ... // ... // ... }; /**************************************************************** ***** Monitoring initialization, DO NOT MODIFY THIS !!! ***** ****************************************************************/ const uint8_t nbVariables = sizeof( variables ) / sizeof( sVariables_t ); Monitoring myMonitor( &Serial, variables, nbVariables ); /**************************************************************** ***** End of Monitoring initialization ***** ****************************************************************/ // Your setup void setup() { // ... // ... // ... } // Your loop void loop() { // ... // ... // ... // You need to add this line at the end of the loop // This line call the monitoring engine for the communication // with the papyMonitor-gui application // The call act as a blocking timer, after 1ms it unblocks the line // Further behaviour will be available if requested myMonitor.update(); } Of course, this code is useless but shows what is absolutelly necessary in your sketch. Example Assume you want to monitor two variables, one of the type Byte and one of the type float , the following sketch example shows how to do this: #include \"papyMonitor.hpp\" // Some variables to monitor // These are the declaration of the variables we want to monitor. They must be // declared before the \"sVariables_t variables[]\" float myFloat; uint8_t myByte; // In order for the library to work, we need to tell it what variable // to monitor, this is done in the sVariables_t variables[] // In the sVariables_t variables[] we put one line per variable // Each line contains 4 fields // 1. The variable pointer (simply put a & in front of your variable) // 2. The variable type (see eDataType_t in papyMonitor.hpp), // 3. A flag that contains the reporting status (eNeverReport, eReportOff, eReportOn) // leave it at eReportOn for the moment // 4. A Callback function, leave it at NULL for the moment sVariables_t variables[] = { { &myFloat, eComDataType_Float, eReportOn, NULL }, //index 0 in the .lua file { &myByte, eComDataType_U8, eReportOn, NULL }, //index 1 in the .lua file }; // The variables[] is in fact an array whose elements have an index. This is // very important to note since each index is related with a peculiar variable // and will be required in the .lua configuration file for the papyMonitor-gui const uint8_t nbVariables = sizeof( variables ) / sizeof( sVariables_t ); Monitoring myMonitor( &Serial, variables, nbVariables ); void setup() { // Initialization of the variables myFloat = 0.0f; myByte = 0; } void loop() { // Main program // We increment the myFloat value from 0 to 100 forever // in step of 0.01 myFloat += 0.01f; if (myFloat >= 100.0f) myFloat = 0.0f; // We increment the myByte value from 0 to 255 forever myByte++; myMonitor.update(); // unblock every 1ms } The matching .lua configuration file can be: -- Lua configuration file -- See \"The User Configuration File (UCF)\"\" documentation cfg:Default({ Baudrate = 230400, SetValue = '#', ReportValueOn = '?', ReportValueOff = '!', IReportValue = ':', IReportTextConsole = '>', SampleTimeHW= 0.001, GroupTabs= { {-- group0 Tabs = { { -- Tab0 TabName=\"Example\", Columns= { { 0, }, { 1 }, } }, }, }, }, Plot=true, }) --------------- cfg:Variable({ Name=\"My float\", Type= \"f\", Index= 0, Data = { { CanPlot=true, } } }) --------------- cfg:Variable({ Name=\"My byte\", Type= \"B\", Index= 1, Data = { { CanPlot=true, } } }) See \"The User Configuration File (UCF)\" documentation for more information","title":"The Arduino target files"},{"location":"targetfilesArduinoCPP/#the-arduino-target-files","text":"The papyMonitor folder of papyMonitor-arduino repository contains two files to include on your project, see installation instruction.","title":"The Arduino target files"},{"location":"targetfilesArduinoCPP/#how-it-works","text":"Each sketch must have some mandatory lines, here after is the minimal sketch to use together with the library // Mandatory include #include \"papyMonitor.hpp\" // Some variables to monitor // ... // ... // ... // The structure where you put your variables // to monitor. The library uses this sVariables_t variables[] = { // ... // ... // ... }; /**************************************************************** ***** Monitoring initialization, DO NOT MODIFY THIS !!! ***** ****************************************************************/ const uint8_t nbVariables = sizeof( variables ) / sizeof( sVariables_t ); Monitoring myMonitor( &Serial, variables, nbVariables ); /**************************************************************** ***** End of Monitoring initialization ***** ****************************************************************/ // Your setup void setup() { // ... // ... // ... } // Your loop void loop() { // ... // ... // ... // You need to add this line at the end of the loop // This line call the monitoring engine for the communication // with the papyMonitor-gui application // The call act as a blocking timer, after 1ms it unblocks the line // Further behaviour will be available if requested myMonitor.update(); } Of course, this code is useless but shows what is absolutelly necessary in your sketch.","title":"How it works"},{"location":"targetfilesArduinoCPP/#example","text":"Assume you want to monitor two variables, one of the type Byte and one of the type float , the following sketch example shows how to do this: #include \"papyMonitor.hpp\" // Some variables to monitor // These are the declaration of the variables we want to monitor. They must be // declared before the \"sVariables_t variables[]\" float myFloat; uint8_t myByte; // In order for the library to work, we need to tell it what variable // to monitor, this is done in the sVariables_t variables[] // In the sVariables_t variables[] we put one line per variable // Each line contains 4 fields // 1. The variable pointer (simply put a & in front of your variable) // 2. The variable type (see eDataType_t in papyMonitor.hpp), // 3. A flag that contains the reporting status (eNeverReport, eReportOff, eReportOn) // leave it at eReportOn for the moment // 4. A Callback function, leave it at NULL for the moment sVariables_t variables[] = { { &myFloat, eComDataType_Float, eReportOn, NULL }, //index 0 in the .lua file { &myByte, eComDataType_U8, eReportOn, NULL }, //index 1 in the .lua file }; // The variables[] is in fact an array whose elements have an index. This is // very important to note since each index is related with a peculiar variable // and will be required in the .lua configuration file for the papyMonitor-gui const uint8_t nbVariables = sizeof( variables ) / sizeof( sVariables_t ); Monitoring myMonitor( &Serial, variables, nbVariables ); void setup() { // Initialization of the variables myFloat = 0.0f; myByte = 0; } void loop() { // Main program // We increment the myFloat value from 0 to 100 forever // in step of 0.01 myFloat += 0.01f; if (myFloat >= 100.0f) myFloat = 0.0f; // We increment the myByte value from 0 to 255 forever myByte++; myMonitor.update(); // unblock every 1ms } The matching .lua configuration file can be: -- Lua configuration file -- See \"The User Configuration File (UCF)\"\" documentation cfg:Default({ Baudrate = 230400, SetValue = '#', ReportValueOn = '?', ReportValueOff = '!', IReportValue = ':', IReportTextConsole = '>', SampleTimeHW= 0.001, GroupTabs= { {-- group0 Tabs = { { -- Tab0 TabName=\"Example\", Columns= { { 0, }, { 1 }, } }, }, }, }, Plot=true, }) --------------- cfg:Variable({ Name=\"My float\", Type= \"f\", Index= 0, Data = { { CanPlot=true, } } }) --------------- cfg:Variable({ Name=\"My byte\", Type= \"B\", Index= 1, Data = { { CanPlot=true, } } }) See \"The User Configuration File (UCF)\" documentation for more information","title":"Example"},{"location":"targetfilesGenericC/","text":"The generic C target files The papyMonitor-microcontroller-generic repository contains two files to include on your project, see installation instruction. How it works The files monitoring.c and monitoring.h are the mandatory files to add to your embedded project. These files must not be modified until you know what you are doing. Let's take a look to monitoring.h : #ifndef MONITORING_H_ #define MONITORING_H_ #include \"stdint.h\" #include \"stdbool.h\" // Meaning codes typedef enum { // Commands from monitor to target; eSetValue = '#', eReportValueOn = '?', eReportValueOff = '!', // Messages from target to monitor eIReportValue = ':', eIReportTextConsole = '>', } eHostMonitoringCmd_t; typedef enum { eComDataType_Float = 'f', // 8 chars eComDataType_U32 = 'W', // 8 chars eComDataType_I32 = 'w', // 8 chars eComDataType_U16 = 'I', // 4 chars eComDataType_I16 = 'i', // 4 chars eComDataType_U8 = 'B', // 2 chars eComDataType_I8 = 'b', // 2 chars } eDataType_t; typedef enum { eNeverReport, eReportOn, eReportOff, } eReportType_t; typedef struct { void* data; // Pointer to the data eDataType_t type; eReportType_t report; bool (*cb)(uint8_t); // Callback with index of the variable in the table as argument } sVariables_t; // Optional helper functions bool setVariablesReportingAllOn( uint8_t dummy ); bool setVariablesReportingAllOff( uint8_t dummy ); /* * Must be called Every X microsecond * Report variables */ void update( void ); #endif /* MONITORING_H_ */ There are enum definitions that are used by monitoring.c file and the sVariables_t structure. The sVariables_t structure is defined in your project and contains the variables to report/edit. The update function is a function that you have to call every X (micro or milli) seconds for the variables to be reported. One value is reported at a time. This function checks also for command arrival and execute it. Let's take a look to the beginning of monitoring.c : #include \"stdio.h\" #include \"stdbool.h\" #include \"stdint.h\" #include \"string.h\" #include \"math.h\" #include \"monitoring.h\" extern char msgFromHost[]; // defined in uart.c extern bool messagePending; // defined in uart.c extern void sendDataHost( char* message ); // defined in uart.c extern sVariables_t variables[]; extern const uint8_t nbVariables; There are 5 extern objects that you must define in your project: msgFromHost[] is a buffer that you must define and initialise with a length of 13 char (minimum). This buffer must contain any message from the host, you have to write the code for the serial receiving. On your code, as soon as a string terminates with a '\\n', copy it to msgFromHost and set the flag messagePending to true. See the code example hereafter. messagePending is a boolean that you must define and initialize to false . When your serial receiving code has set the msgFromHost buffer, it must also set messagePending to true to tell monitoring.c that a new command is arrived. monitoring.c take care to reset messagePending to false. sendDataHost(char*message) is a function that you must define. This function has to send over the serial port the buffer message. The buffer message length is 14 chars maximum and ALWAYS terminate with '\\0' (it's a string). variables[] is an array of objects in which you put your variables to report. See the code example hereafter. nbVariables is the number of elements in variables[] , you must define this. See the code example hereafter. Code example /* * THIS IS A BASIC FILE JUST TO SHOW HOW TO * DEFINE AND INITIALIZE THE VARIABLES NEEDED BY monitoring.c * THIS FILE IS NOT OPTIMIZED AT ALL */ #include \"monitoring.h\" #include \"string.h\" #include \"structures.h\" // Variables the project is using float myFloat1, myFloat2; // In order for the library to work, we need to tell it what variable // to monitor, this is done in the sVariables_t variables[] // In the sVariables_t variables[] we put one line per variable // Each line contains 4 fields // 1. The variable pointer // 2. The variable type (see eDataType_t in papyMonitor.hpp), // 3. A flag that contains the reporting status (eNeverReport, eReportOff, eReportOn) // leave it at eReportOn for the moment // 4. A Callback function, leave it at NULL for the moment sVariables_t variables[] = { { (void *) &myFloat1, eComDataType_Float, eReportOn, NULL }, // Index 0 { (void *) &myFloat2, eComDataType_Float, eReportOn, NULL }, // Index 1 }; // Create and init the nbVariables var const uint8_t nbVariables = sizeof( variables ) / sizeof( sVariables_t ); // Create the msgFromHost[] var char msgFromHost[14]; // Create the messagePending flag bool messagePending = false; /* **************************************************************************** * Create your serial receive handler * used when the host send a command * This handler set msgFromHost[] and messagePending ****************************************************************************/ // This is just an example void UART0_IRQHandler( void ) { static uint8_t idxRX = 0; static uint8_t localBuffer[14]; // Local buffer for double buffering // A byte is arrived, store it to a local buffer char c = Chip_UART_ReadByte( LPC_USART0 ); localBuffer[idxRX] = c; if ( (c == '\\r') || (c == '\\n') ) { // Copy to msgFromHost for monitoring.c memcpy( msgFromHost, interruptMezza2Stab.msgString, idxRX); // Say to monitoring.c that a message is pending messagePending = true; // Reset reception idxRX = 0; } else { idxRX++; // Overflow protection if ( idxRX == 13) idxRX = 0; } } // Create the sendDataHost function void sendDataHost( char* msgString ) { uint8_t i=0; while(msgString[i]!=0) { //Your function for serial sending char sendChar(msgString[i]); } } /* **************************************************************************** * Your main function ****************************************************************************/ int main( void ) { while(1) { // Do your stuff myFloat1 = ... muFloat2 = getADCValue(...); // Call the update function // each X (micro-milli) second if (YourTimerReachXSecond) update(); } return 0; } For a more complete example, see the example02 in the examples folder","title":"The generic C target files"},{"location":"targetfilesGenericC/#the-generic-c-target-files","text":"The papyMonitor-microcontroller-generic repository contains two files to include on your project, see installation instruction.","title":"The generic C target files"},{"location":"targetfilesGenericC/#how-it-works","text":"The files monitoring.c and monitoring.h are the mandatory files to add to your embedded project. These files must not be modified until you know what you are doing. Let's take a look to monitoring.h : #ifndef MONITORING_H_ #define MONITORING_H_ #include \"stdint.h\" #include \"stdbool.h\" // Meaning codes typedef enum { // Commands from monitor to target; eSetValue = '#', eReportValueOn = '?', eReportValueOff = '!', // Messages from target to monitor eIReportValue = ':', eIReportTextConsole = '>', } eHostMonitoringCmd_t; typedef enum { eComDataType_Float = 'f', // 8 chars eComDataType_U32 = 'W', // 8 chars eComDataType_I32 = 'w', // 8 chars eComDataType_U16 = 'I', // 4 chars eComDataType_I16 = 'i', // 4 chars eComDataType_U8 = 'B', // 2 chars eComDataType_I8 = 'b', // 2 chars } eDataType_t; typedef enum { eNeverReport, eReportOn, eReportOff, } eReportType_t; typedef struct { void* data; // Pointer to the data eDataType_t type; eReportType_t report; bool (*cb)(uint8_t); // Callback with index of the variable in the table as argument } sVariables_t; // Optional helper functions bool setVariablesReportingAllOn( uint8_t dummy ); bool setVariablesReportingAllOff( uint8_t dummy ); /* * Must be called Every X microsecond * Report variables */ void update( void ); #endif /* MONITORING_H_ */ There are enum definitions that are used by monitoring.c file and the sVariables_t structure. The sVariables_t structure is defined in your project and contains the variables to report/edit. The update function is a function that you have to call every X (micro or milli) seconds for the variables to be reported. One value is reported at a time. This function checks also for command arrival and execute it. Let's take a look to the beginning of monitoring.c : #include \"stdio.h\" #include \"stdbool.h\" #include \"stdint.h\" #include \"string.h\" #include \"math.h\" #include \"monitoring.h\" extern char msgFromHost[]; // defined in uart.c extern bool messagePending; // defined in uart.c extern void sendDataHost( char* message ); // defined in uart.c extern sVariables_t variables[]; extern const uint8_t nbVariables; There are 5 extern objects that you must define in your project: msgFromHost[] is a buffer that you must define and initialise with a length of 13 char (minimum). This buffer must contain any message from the host, you have to write the code for the serial receiving. On your code, as soon as a string terminates with a '\\n', copy it to msgFromHost and set the flag messagePending to true. See the code example hereafter. messagePending is a boolean that you must define and initialize to false . When your serial receiving code has set the msgFromHost buffer, it must also set messagePending to true to tell monitoring.c that a new command is arrived. monitoring.c take care to reset messagePending to false. sendDataHost(char*message) is a function that you must define. This function has to send over the serial port the buffer message. The buffer message length is 14 chars maximum and ALWAYS terminate with '\\0' (it's a string). variables[] is an array of objects in which you put your variables to report. See the code example hereafter. nbVariables is the number of elements in variables[] , you must define this. See the code example hereafter.","title":"How it works"},{"location":"targetfilesGenericC/#code-example","text":"/* * THIS IS A BASIC FILE JUST TO SHOW HOW TO * DEFINE AND INITIALIZE THE VARIABLES NEEDED BY monitoring.c * THIS FILE IS NOT OPTIMIZED AT ALL */ #include \"monitoring.h\" #include \"string.h\" #include \"structures.h\" // Variables the project is using float myFloat1, myFloat2; // In order for the library to work, we need to tell it what variable // to monitor, this is done in the sVariables_t variables[] // In the sVariables_t variables[] we put one line per variable // Each line contains 4 fields // 1. The variable pointer // 2. The variable type (see eDataType_t in papyMonitor.hpp), // 3. A flag that contains the reporting status (eNeverReport, eReportOff, eReportOn) // leave it at eReportOn for the moment // 4. A Callback function, leave it at NULL for the moment sVariables_t variables[] = { { (void *) &myFloat1, eComDataType_Float, eReportOn, NULL }, // Index 0 { (void *) &myFloat2, eComDataType_Float, eReportOn, NULL }, // Index 1 }; // Create and init the nbVariables var const uint8_t nbVariables = sizeof( variables ) / sizeof( sVariables_t ); // Create the msgFromHost[] var char msgFromHost[14]; // Create the messagePending flag bool messagePending = false; /* **************************************************************************** * Create your serial receive handler * used when the host send a command * This handler set msgFromHost[] and messagePending ****************************************************************************/ // This is just an example void UART0_IRQHandler( void ) { static uint8_t idxRX = 0; static uint8_t localBuffer[14]; // Local buffer for double buffering // A byte is arrived, store it to a local buffer char c = Chip_UART_ReadByte( LPC_USART0 ); localBuffer[idxRX] = c; if ( (c == '\\r') || (c == '\\n') ) { // Copy to msgFromHost for monitoring.c memcpy( msgFromHost, interruptMezza2Stab.msgString, idxRX); // Say to monitoring.c that a message is pending messagePending = true; // Reset reception idxRX = 0; } else { idxRX++; // Overflow protection if ( idxRX == 13) idxRX = 0; } } // Create the sendDataHost function void sendDataHost( char* msgString ) { uint8_t i=0; while(msgString[i]!=0) { //Your function for serial sending char sendChar(msgString[i]); } } /* **************************************************************************** * Your main function ****************************************************************************/ int main( void ) { while(1) { // Do your stuff myFloat1 = ... muFloat2 = getADCValue(...); // Call the update function // each X (micro-milli) second if (YourTimerReachXSecond) update(); } return 0; } For a more complete example, see the example02 in the examples folder","title":"Code example"},{"location":"theGUIApplication/","text":"The GUI application The figure below shows the application when started. Is the menu region: The File button permits to load the .lua configuration file. The Parameters button load/save/send to target the variables tagged with Parameters key. The Open port button open/close the serial port. Is the user area that will contains the variables in user defined tabs and -if requested- the plotter and the 3D viewer. Is the console that permits to display informations and errors as well as user messages from the target. Is the status bar containing a counter for serial error transmission. The figure below shows the application when a .lua configuration file is loaded. In this case, the user asked to have the plotter and the 3D viewer. You'll find this .lua file in the example02 of the examples folder in the papyMonitor-microcontroller-generic repository. Once a valid .lua configuration file is loaded, the Open port button is no more greyed and -when clicked- the user can select the target related serial port among the ones that appears on the list. Each variable has a small M next to it. This is a button that permits to enable/disable the monitoring for the variable. There are four GroupTabs, the last one is a Commands tab, read the .lua file at the end to see how to do it. The plotter has a button that permits to show the variables that are enabled for plotting. The user can select the color of each variable curve. The scope mode displays the variables as if it was displayed on a oscilloscope. The triggering button permits to trig to one variable, when enabled a black draggable horizontal line set the trigger level. When the pointer is over the plotter, one can interact with it with the mouse buttons and the mouse wheel (pressing ctrl + wheel change the Y division). The 3D viewer shows the shapes defined/loaded by the .lua file. When the pointer is over the 3D view, one can interact with it with the mouse buttons and the mouse wheel.","title":"The GUI application"},{"location":"theGUIApplication/#the-gui-application","text":"The figure below shows the application when started. Is the menu region: The File button permits to load the .lua configuration file. The Parameters button load/save/send to target the variables tagged with Parameters key. The Open port button open/close the serial port. Is the user area that will contains the variables in user defined tabs and -if requested- the plotter and the 3D viewer. Is the console that permits to display informations and errors as well as user messages from the target. Is the status bar containing a counter for serial error transmission. The figure below shows the application when a .lua configuration file is loaded. In this case, the user asked to have the plotter and the 3D viewer. You'll find this .lua file in the example02 of the examples folder in the papyMonitor-microcontroller-generic repository. Once a valid .lua configuration file is loaded, the Open port button is no more greyed and -when clicked- the user can select the target related serial port among the ones that appears on the list. Each variable has a small M next to it. This is a button that permits to enable/disable the monitoring for the variable. There are four GroupTabs, the last one is a Commands tab, read the .lua file at the end to see how to do it. The plotter has a button that permits to show the variables that are enabled for plotting. The user can select the color of each variable curve. The scope mode displays the variables as if it was displayed on a oscilloscope. The triggering button permits to trig to one variable, when enabled a black draggable horizontal line set the trigger level. When the pointer is over the plotter, one can interact with it with the mouse buttons and the mouse wheel (pressing ctrl + wheel change the Y division). The 3D viewer shows the shapes defined/loaded by the .lua file. When the pointer is over the 3D view, one can interact with it with the mouse buttons and the mouse wheel.","title":"The GUI application"}]}